# 2023/12/07
# 取り組んだ課題
DB設計の課題
REST API
  
# 次やる課題
REST API

# 学んだこと
## データフォーマット
主要なレスポンスフォーマットは3種類。
1. XML
    ```
    <user>
        <name>tanaka</tanaka>
    </user>
    ```
    * テキスト形式
    * タグで記述
    * タグは入れ子にできる
    * タグに属性が付けられる
1. JSON
    ```
    {
        user: {name: "tanaka"}
    }
    ```
    * テキスト形式
    * javascriptを元にしたフォーマット
    * XMLに比べてデータ量が減らせる。
    * オブジェクトは入れ子にできる
1. JSONP
    ```
    callback( {user: {name: "tanaka"}} )
    ```
    * テキスト形式
    * javascriptコード
    * クロスドメインでデータを受け渡すことができる
データフォマットの指定方法は3種類。
クエリパラメータ（利用が多い）、拡張子（あまり見かけない）、リクエストヘッダー

## データの内部構造の設計ポイント
* エンベロープは使わない
* オブジェクトはできるだけフラットにする
* ページネーションをサポートする情報を返す
* プロパティの命名規則はAPI全体で統一する
* 日付はRFC3339(W3C-DTF)形式を使う
* 大きな数値(64BIT整数)は文字列で返す

## エラー表現の設計ポイント
* エラー詳細はレスポンスボディに入れる
* エラーの際にHTMLが返らないようにする
* サービス閉塞時は"503"+"Retry-After"

# REST WebAPIサービス設計（応用）
## APIバージョンを含めるか
* メリット: 特定バージョン指定でアクセスできるので、クライアント側で突然えらーにはならない
* デメリット: 複数バージョンを並列稼働させるため、ソースコードやデータベースの管理が複雑になる
広く世間一般に公開するようなサービスを展開するのであれば利用者の利便性を考慮してAPIバージョンを含めたURLの設計を行う

### バージョンを入れる場所は3種類
1. パス（このケースが多い）
1. クエリ
1. ヘッダー（サービス固有の接頭辞をつける、REST APIの設計上はヘッダーに入れるのがおすすめ）

### バージョンの付け方
セマンティックバージョニングがよく知られている。（バージョン：　1(メジャー).2(マイナー).3(パッチ)）
|メジャー|マイナー|パッチ|
|:---|:---|:---|
|後方互換しない修正|後方互換する機能追加|後方互換するバグ修正|
APIは`後方互換しなくなったタイミング（メジャー）で付ける`のがおすすめ。

## 認証と認可
認証は `本人特定` 、認可は `アクセス制御` 。
OAuthもOpenID Connectも認可の仕組み。OpenID ConnectはOAuthに本人情報取得を加えた仕組み。

### OAuth
Authorization Code　フロー：アクセストークン (認可に必要) のみが使用される。

### OpenID Connect
codeフロー：アクセストークンに加えて、認証に必要なIDトークン (認証結果情報/JWT) も使用される。

## JSON Web Token (JWT/ジョット)
* 特徴は署名による改ざんチェック、URL-safeなデータ、データの中身はJSON形式
* 特に認証や情報の交換に使用される
* 用途としては、認証結果をサーバー側で保存せずに、クライアント側の保持 (ステートレスな通信の実現)

### 基本構造
`ヘッダー　+ "." + ペイロード+ "." + 署名`
1. ヘッダー
署名で利用するアルゴリズムなどを定義、algはnone以外を指定
1. ペイロード
保存したいデータの実態、セッションにデータを保存して使うイメージ
1. 署名
改竄されていないか確認するための署名

## レートリミット
WEBアプリをAPI化することで意図しない大量アクセスを防ぐために、時間あたりのアクセス制限（レートリミット）をかける対策が必要。
### レートリミットの設計
* 誰に対して（APIキー、ユーザーID...）
* 何に対して（単一機能、機能群、API全体...）
* 制限回数（10回、100回、1000回...）
* 単位時間(10分、1時間、1日...)
### レートリミットのアルゴリズム
* Fixed Window(時間枠が固定で決まっている、教会時間前後の枠でレートリミットの倍のアクセスがあることも...)
* Sliding Log（過去制限時間分のログを確認、過去ログの大量保存が問題）
* Sliding Window（上記2つのいいとこ取り）
### アクセス制限を緩和するケース
* 優良顧客やキャンペーンなどに備えて、アクセス元ごとに一時的に設定変更できる仕組みを考慮する必要がある。

## キャッシュ制御
キャッシュ制御に利用するヘッダーは2分類3パターン
### Expires
* キャッシュとしていつまで利用可能かの期限を指定
* 過去日を指定すると「リソースが有効期限切れ」であることを意味する
* Cache-Controlが同時指定されている場合、Expiresは無視
### Cache-Control + Date
* Cache-Controlでキャッシュの可否、期限を指定
no-cacheはクライアント側に保存されるが通信量が抑えられる、no-storeは保存されないがデータのやり取り発生。
### Last-Modified + ETag
* リソースの最終更新日時を指定
* ETagに特定バージョンを示す文字列を指定

### キャッシュさせる単位
`Vary:`キャッシュ判断に利用するヘッダーを指定


## セキュリティ
WebAPIで代表的な脆弱性対策として、以下の4つが存在する
### XSS
悪意あるユーザーが正規のサイトに不正なスクリプトを挿入することで、正規ユーザーの情報を不正に引き出したり操作できてしまう問題。
* レスポンスヘッダーの追加
1. X-XSS-Protection
`1`で、XSSフィルタリング有効化
1. X-Frame-Options
`DENY`で、frameタグ呼び出しを拒否
1. X-Content-Type-Options
`nosniff`で、IE脆弱性対応

### CSRF
本来拒否しなければいけないアクセス元 (許可しないアクセス元) からくるリクエストを処理してしまう問題。
* 許可しないアクセス元からのリクエストを拒否
1. X-API-Key(独自ヘッダー)
システム単位で実行可否判断
1. Authentication
ユーザー単位で実行可否判断
* 攻撃者に推測されにくいトークンの発行/照合処理を実装
1. X-CSRF-TOKEN(独自ヘッダー)
トークンを使って実行可否判断

### HTTP
通信経路が暗号化されないので盗聴されやすい。
* 常時HTTPSを利用した通信にする
1. TLS
SSLの後継、トークンを使って実行可否判断
1. HTTPS
HTTP+SSL/TLS
1. X-CSRF-TOKEN
トークンを使って実行可否判断


# 学習時間
2h（合計388h）
