# 2023/11/29
# 取り組んだ課題
達人に学ぶDB設計
  
# 次やる課題
達人に学ぶDB設計

# 学んだこと
## 一歩進んだ論理設計
* リレーショナルデータベースには表現することが苦手なデータ形式がある。その代表格が木（tree）構造。
* 木構造を表現する伝統的な手段として、隣接リストモデルという方法があるが、これはSQL文を複雑にする難しい方法である。
* 近年、隣接リストモデルに代わる新しい方法論が考えられている。（入れ子集合モデル、入れ子区間モデル、経路列挙モデル）
* 伝統的な解法は隣接リストモデル
### 入れ子集合モデル
ノードを円と見なす。「右端 - 左端」の引き算で円の直径が決まる。
#### 検索
利点は木構造を操作するためのSQL文が隣接リストモデルに比べて非常にシンプルになる。
* ルートとリーフを求める
ルート: 他のどんな円にも含まれない円
リーフ: 自分の中に他の円を1つも含まれない円
* 木の深さを求める
ノードの深さを求める場合は「自分を包含する円が何個あるか」という風に`包含関係`に翻訳する。
木の高さもこの結果から最大に深さを求めればいい。
#### 更新
* ノードの追加
ノードを追加する場合はリーフなのか親なのかによって処理が分かれる。
更新対象と無関係な円の座標も連動して更新しなければならないこと（更新時のパフォーマンス）が最大の弱点である。
* ノードの削除
該当のレコードを削除するのみ。
座標の絶対値が重要なわけではなく、包含関係という相対的な関係が保持されていれば十分である。
### 入れ子区間モデル
円の左端/右端の座標値としてとれる範囲を実数まで広げた、入れ子集合モデルの拡張版が`入れ子区間モデル`。
### 経路列挙モデル
ノードをディレクトリ（フォルダ）と見なし、各ノードまでの経路(PATH)を記述する。
パス文字列の包含関係で表現しており、子は親のパスを含むという、入れ子集合とは反対の包含関係になる。
利点は検索のパフォーマンスがいいこと、欠点は経路に主キーを使用すると経路の文字列が長大になる、同じ階層内のノード同士の順序が一般的に把握できない、パスに番号を使うとノードの削除、追加などの更新が複雑になる、文字列関数の標準化が遅れているSQLではかなり実装依存のコードになってしまう。
つまり、検索が簡単で更新が複雑になる。
#### 検索
* ルートとリーフを探す
経路に主キーを使用している場合は区切り文字を削除した文字列がキーと同じになる。
* 木の深さを求める
経路列に含まれる区切り文字を数えれば0を開始値とする深さが求められる。
#### 更新
* ノードの追加
親ノードとして追加する場合は新たに抱える子ノードの数だけ、経路更新のUPDATE文をループで繰り返す必要がある。
* 部分木の削除
サブクエリ内のSELECT文によって、削除対象となる部分木のルートの経路を求める。残りの子ノードたちは、いずれもこの経路を前半に含む経路をもっているので、LIKEの前方一致検索が使えるようになる。

# 学習時間
2h（合計372h）
